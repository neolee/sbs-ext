#!/usr/bin/env node
import { readFile, writeFile } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import { Chess } from '../vendor/chess.mjs'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const ROOT = path.resolve(__dirname, '..')
const SOURCE_PGN = path.join(ROOT, 'data', 'chessjs-benchmark.pgn')
const OUTPUT_JSON = path.join(ROOT, 'eco-dictionary.json')
const OUTPUT_MODULE = path.join(ROOT, 'eco-dictionary.js')
const ZH_OVERRIDE_PATH = path.join(ROOT, 'data', 'eco-zh.json')
const ZH_WIKI_PATH = path.join(ROOT, 'data', 'eco-zh-wikipedia.json')

const raw = await readFile(SOURCE_PGN, 'utf8')
const chunks = raw
  .split(/\n(?=\[Event )/g)
  .map((chunk) => chunk.trim())
  .filter(Boolean)

let zhOverrides = {}
try {
  const zhRaw = await readFile(ZH_OVERRIDE_PATH, 'utf8')
  zhOverrides = JSON.parse(zhRaw)
} catch (err) {
  console.warn('[build-eco-table] zh override file missing or invalid, continuing with fallbacks')
}

let zhWiki = {}
try {
  const zhWikiRaw = await readFile(ZH_WIKI_PATH, 'utf8')
  const wikiPayload = JSON.parse(zhWikiRaw)
  zhWiki = wikiPayload.entries || wikiPayload
} catch (err) {
  console.warn('[build-eco-table] zh wiki file missing or invalid, continuing with fallbacks')
}

const zhTranslations = {
  ...zhWiki,
  ...zhOverrides
}

const entries = []
for (const chunk of chunks) {
  const chess = new Chess()
  chess.loadPgn(chunk, { sloppy: true })
  const headers = chess.getHeaders()
  if (!headers.ECO) {
    continue
  }
  const moves = chess.history()
  if (!moves.length) {
    continue
  }
  const labels = {
    en: headers.Opening || null,
    zh: zhTranslations[headers.ECO] || zhTranslations[headers.Opening] || headers.Opening || null
  }

  entries.push({
    eco: headers.ECO,
    labels,
    moves
  })
}

const lookup = {}
for (const entry of entries) {
  const prefix = []
  for (const move of entry.moves) {
    prefix.push(move)
    const key = prefix.join(' ')
    const existing = lookup[key]
    if (!existing || existing.ply <= prefix.length) {
      lookup[key] = {
        eco: entry.eco,
        labels: entry.labels,
        ply: prefix.length
      }
    }
  }
}

const payload = {
  generatedAt: new Date().toISOString(),
  source: path.relative(ROOT, SOURCE_PGN),
  positions: Object.keys(lookup).length,
  lookup
}

await writeFile(OUTPUT_JSON, JSON.stringify(payload, null, 2) + '\n', 'utf8')

const moduleBanner = `// Auto-generated by scripts/build-eco-table.mjs on ${payload.generatedAt}\n// Source PGN: ${path.relative(ROOT, SOURCE_PGN)}\n\n`
const moduleBody = `export const ECO_DICTIONARY = ${JSON.stringify(payload, null, 2)};\n\nexport const ECO_LOOKUP = ECO_DICTIONARY.lookup;\n\nexport default ECO_DICTIONARY;\n`
await writeFile(OUTPUT_MODULE, moduleBanner + moduleBody, 'utf8')

console.log(
  `Wrote ${payload.positions} ECO entries to ${path.relative(ROOT, OUTPUT_JSON)} ` +
  `and ${path.relative(ROOT, OUTPUT_MODULE)}`
)
